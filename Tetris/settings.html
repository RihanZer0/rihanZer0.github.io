<!DOCTYPE html>
<html>
    <head>
        <title>Тетрис на Canvas &mdash; Настройки</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="generator" content="" />
        <title>Тетрис на Canvas</title>
        <style type="text/css">
            * { font-family: "Verdana", sans-serif; }
            details ul { list-style-type: none; margin-top: 0.1em; }
            details { margin-top: 0.2em; margin-bottom: 0.2em; }
            p { margin-top: 1em; margin-bottom: 0; }
            main { display: table-row; width: 100%; }
            section { display: table-cell; }
            main > section:first-child { background-color: transparent; width: 50%; padding-left: 2em; padding-right: 2em; }
            main > section:last-child { background-color: transparent; border-left: solid thin black; padding-left: 2em; vertical-align: bottom; }
            button { white-space: nowrap; }
            td button { padding-left: 0.1em; padding-right: 0.1em; }
            main > section:last-child button { margin-top: 2em; }
            table { margin-top: 0.4em; margin-left: 2em; }
            td, tr { margin: 0; padding: 0; }
            td.keyCode { text-align: right; }
            tr > td:first-child { padding-right: 0.2em; }
            input[type=text] { margin-left: 0.2em; }
            input[type=checkbox] { margin: 0; }
            table.default select { width: 8em; }
            details table:last-child { margin-bottom: 1em; }
            ul.keyboard button { padding: 0; padding-left: 0.2em; padding-right: 0.2em; }
            ul.keyboard button, ul.keyboard li input { margin: 0; }
            ul.keyboard input { width: 12em; }
            #keyEditor { display: none; position: absolute; background-color: moccasin; padding: 0.2em; padding-left: 1em; padding-right: 1em;  }
            aside { width: 2em; height: 1em; display: inline-block; margin-right: 0.4em; }
        </style>
    <head>
<body>

<h2>Настройки <span id="badBrowser"></span></h2>

<div id="keyEditor"></div>

<h4>Тетрис на Canvas </h4>

<main>

<section>

<details open="true">
    <summary>Размер игрового поля</summary>
    <table class="default">
        <tr>
            <td>Горизонтальные блоки:</td><td><select data-property="gameSizeInBlocks.x" data-editor="gameSizeInBlocksEditor.x"></select></td>
        </tr>
        <tr>
            <td>Вертикальные:</td><td><select data-property="gameSizeInBlocks.y" data-editor="gameSizeInBlocksEditor.y"></td>
        </tr>
    </table>
</details>

<details open="true">
    <summary>Отсрочки</summary>
    <table class="default">
        <tr>
            <td>Изначально:</td><td><select data-property="delays.start" data-editor="delaysEditor.start"></select></td>
        <tr>
            <td>Сокращение:</td><td><select data-property="delays.decrement" data-editor="delaysEditor.decrement"></select></td>
        </tr>
        <tr>
            <td>Минимальная:</td><td><select data-property="delays.min" data-editor="delaysEditor.min"></select></li></td>
        </tr>
    </table>
</details>

<details open="true">
    <summary>Цвета</summary>
    <table class="colors">
		<tr>
			<td><img id="image.I" src="images/settings.I.png"/></li>
		    <td><img id="image.O" src="images/settings.O.png"/></td>
			<td><img id="image.T" src="images/settings.T.png"/></li>
		</tr>
		<tr>
		    <td><select data-property="tetrominoColor.I"></select></td>
			<td><select data-property="tetrominoColor.O"></select></td>
			<td><select data-property="tetrominoColor.T"></select></td>
		</tr>
	</table>
	<table class="colors">
        <tr>
        <td><img id="image.J" src="images/settings.J.png"/></li>
        <td><img id="image.L" src="images/settings.L.png"/></td>
		<td><img id="image.Z" src="images/settings.Z.png"/></td>
		<td><img id="image.S" src="images/settings.S.png"/></li>
        </tr>
        <tr>
        <td><select data-property="tetrominoColor.J"></select></td>
        <td><select data-property="tetrominoColor.L"></select></td>
        <td><select data-property="tetrominoColor.Z"></select></td>
		<td><select data-property="tetrominoColor.S"></select></td>
        </tr>
    </table>
</details>

<details>
    <summary>Беспорядок</summary>
    <table class="default">
        <tr>
            <td><label for="clutterEnabledDefault">Включено по умолчанию</td><td><input type="checkbox" data-property="clutterOptionSet.clutterEnabledDefault" id="clutterEnabledDefault"></input></label></td>
        </tr>
        <tr>
            <td>Минимальный:</td><td><select data-property="clutterOptionSet.min" data-editor="clutterEditor.min"></select></td>
        </tr>
        <tr>
            <td>Максимальный:</td><td><select data-property="clutterOptionSet.max" data-editor="clutterEditor.max"></select></td>
        </tr>
        <tr>
            <td>Шаг:</td><td><select data-property="clutterOptionSet.step" data-editor="clutterEditor.step"></select></td>
        </tr>
        <tr>
            <td>Стадартное значение:</td><td><select accesskey="D" data-property="clutterOptionSet.default" data-editor="clutterEditor.default"></select></td>
        </tr>    
    </table>
</details>

<details>
    <summary>Управление</summary>
    <table>
        <tr data-property="key.start">
            <td>Старт/Пауза/Продолжение:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.cancel">
            <td>Отмена игры:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.left">
            <td>Влево:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.right">
            <td>Вправо:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.down">
            <td>Вниз:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.dropDown">
            <td>Сброс тетрамино вниз:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.rotate">
            <td>Вращение:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.help">
            <td>Помощь:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.settings">
            <td>Настройки:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td> 
        </tr>
    </table>
</details>

</section>

<section>
    <button id="apply" title="Store custom settings and play game">Подтвердить</button><br/>
    <button id="reset" accesskey="R" title="Reset settings to default values">Сбросить</button><br/>
    <button id="clean" accesskey="L" title="Clean Tetris data from browser local storage">Очистить локальное хранилище</button>    
</section>

</main>

<script src="settings.js"></script>
<script>
    
    "use strict";

    const setTargetImage = (node) => {
        const cell = node.parentElement;
        if (cell.constructor != HTMLTableCellElement) return;
        let tetrominoName = node.dataset.property.split('.');
        tetrominoName = tetrominoName[tetrominoName.length - 1];
        const tetrominoId = "image." + tetrominoName;
        const targetImage = document.getElementById(tetrominoId);
        if (!targetImage) return null; 
        node.targetImage = targetImage; 
        return targetImage;
    }; //setTargetImage

    const detectKeyboardEditorElements = (node) => {
        const numericKeyCodeElement = node.firstElementChild.nextSibling;
        const button = node.lastElementChild.lastElementChild;
        const inputName = node.lastElementChild.firstElementChild;
        return { numericKeyCodeElement: numericKeyCodeElement, button: button, inputName: inputName };
    }; //detectKeyboardEditorElements

    const populate = (elements, defaultOnly) => {
        const effectiveSettings = getSettings(defaultOnly);
        const effectiveSettingsNamePrefix = settingsEditor.getVariableName({effectiveSettings}) + ".";
        settingsEditor.traverse(document.body, function(node) {
            if (!node.dataset) return;
            if (!node.dataset.property) return;
            let value = eval(effectiveSettingsNamePrefix + node.dataset.property);
            if (node.constructor == HTMLTableRowElement) { // keyboard
                const keyboardEditorElements = detectKeyboardEditorElements(node);            
                keyboardEditorElements.numericKeyCodeElement.textContent = value.keyCode;
                keyboardEditorElements.inputName.value = value.display;
                keyboardEditorElements.inputName.data = {};
                keyboardEditorElements.inputName.data.keyCode = value.keyCode;
                keyboardEditorElements.button.onclick = () => {
                    elements.keyEditor.tabIndex = 0;
                    elements.keyEditor.onkeydown = (event) => {
                        event.preventDefault();
                        event.target.innerHTML = event.keyCode;
                        keyboardEditorElements.inputName.value = event.code;
                        keyboardEditorElements.inputName.data = {};
                        keyboardEditorElements.inputName.data.keyCode = event.keyCode;
                        event.target.style.display = "none";
                        keyboardEditorElements.numericKeyCodeElement.textContent = event.keyCode; 
                        keyboardEditorElements.inputName.focus();
                    }; //elements.keyEditor
                    elements.keyEditor.innerHTML = settingsEditor.keyEditorInstruction;
                    elements.keyEditor.style.display = "block";
                    const buttonBounds = keyboardEditorElements.button.getBoundingClientRect();
                    elements.keyEditor.style.top = settingsEditor.sizeStyle((buttonBounds.top + window.pageYOffset));
                    elements.keyEditor.style.left = settingsEditor.sizeStyle((buttonBounds.right + window.pageXOffset));
                    elements.keyEditor.focus();
                }; //keyboardEditorElements.button.onclick
            } else if (node.constructor == HTMLSelectElement) {
                while (node.firstChild)
                    node.removeChild(node.firstChild);
                if (setTargetImage(node)) { // case of image
                    node.onchange = function(event) {
                        if (event.target.targetImage.constructor == HTMLImageElement)
                            event.target.targetImage.style.backgroundColor = event.target.value;
                    }; //node.onselect
                    for (let color of settingsEditor.namedCssColors) {
                        const option = document.createElement("option");
                        const colorBox = document.createElement("aside");
                        colorBox.style.backgroundColor = color;
                        const colorName = document.createTextNode(color);
                        option.appendChild(colorBox);
                        option.appendChild(colorName);
                        option.selected = value.toLowerCase() == color.toLowerCase();
                        option.value = color;
                        node.add(option);
                    } //loop
                    node.targetImage.style.backgroundColor = node.value;
                } else { //if image, now considering text
                    const editorOptionSet = eval(effectiveSettingsNamePrefix + node.dataset.editor);
                    if (!editorOptionSet) return;
                    const count = ((editorOptionSet.max - editorOptionSet.min) / editorOptionSet.step) + 1;
                    const rounder = settingsEditor.findRoundingFactor(editorOptionSet);
                    for (let index = 0; index < count; ++index) {
                        let optionValue = editorOptionSet.min + index * editorOptionSet.step;
                        optionValue = Math.floor(optionValue * rounder) / rounder; 
                        const option = document.createElement("option");
                        option.selected = optionValue == value;
                        option.textContent = optionValue + editorOptionSet.unit;
                        node.add(option);
                    } //loop
                } //if text
            } else if (node.constructor == HTMLInputElement && node.type == "checkbox") {
                node.checked = value;
            } else // не изменяемое
                settingsEditor.setText(node.id, value);
        });
        return effectiveSettings.localStorageAccessible; 
    }; //populate

    const extractKeyboardData = (node) => {
        const parentProperty = eval(node.dataset.property)
        const keyboardEditorElements = detectKeyboardEditorElements(node);
        const keyCode = keyboardEditorElements.inputName.data.keyCode;
        const display = keyboardEditorElements.inputName.value;
        parentProperty.keyCode = keyCode;
        parentProperty.display = display;
        return parentProperty;
    }; //extractKeyboardData

    const apply = () => {
        const target = {};
        settingsEditor.traverse(document.body, function(node) {
            if (!node.dataset) return;
            if (!node.dataset.property) return;
            if (node.constructor != HTMLTableRowElement && node.constructor != HTMLSelectElement && node.type != "checkbox") return;
            const propertyChain = node.dataset.property.split(".");
            let currentObject = target;
            let lastSlot = null;
            let value = null;
            if (node.constructor == HTMLTableRowElement) {
                value = extractKeyboardData(node);
            } else {
                value = node.value;
                if (node.type == "checkbox") 
                    value = node.checked;
                else {
                    const numericValue = parseFloat(node.value);
                    if (!Number.isNaN(numericValue)) value = numericValue;
                } //if
            } //if
            if (value == undefined || value == null) return;
            for (let index = 0; index < propertyChain.length; ++index) {
                if (currentObject[propertyChain[index]] != undefined)
                    currentObject = currentObject[propertyChain[index]];
                else {
                    if (index == propertyChain.length - 1)
                        currentObject[propertyChain[index]] = value;
                    else
                        currentObject[propertyChain[index]] = {};
                    currentObject = currentObject[propertyChain[index]]; 
                } //if
            } //loop slots
        });
        const result = JSON.stringify(target);
        localStorage.setItem(settingsEditor.localStorageKey, result);
        window.location = fileNames.main;
    }; //apply

    window.onload = () => {
        const elements = {
            keyEditor: document.getElementById("keyEditor"),
            buttonApply: document.getElementById("apply"),
            buttonClean: document.getElementById("clean"),
            buttonReset: document.getElementById("reset"),
            badBrowser: document.getElementById("badBrowser")
        };
        const localStorageAccessible = populate(elements, false);
        elements.buttonReset.onclick = () => { populate(elements, true); };
        if (localStorageAccessible) {
            elements.buttonApply.onclick = apply;
            elements.buttonClean.onclick = () => {
                localStorage.removeItem(settingsEditor.localStorageKey);
                location.reload(true);
            }; //buttonClean.onclick
        } else {
            elements.badBrowser.innerHTML = settingsEditor.badBrowserHTML;
            elements.badBrowser.parentElement.style.color = settingsEditor.badBrowserColor;
            elements.buttonApply.disabled = true;
            elements.buttonClean.disabled = true;
        } //if
    }; //window.onload
</script>

</body></html>